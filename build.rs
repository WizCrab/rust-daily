use std::fs;
use std::io::Result;
use std::path::{Path, PathBuf};

const REGISTRY_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/src/registry/");
const REGISTRY_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/src/registry.rs");

const SUBDIR_DETECTED_MSG: &str = "registry can't contain any subdirs!";
const BAD_EXTENSION_MSG: &str = "registry can only contain files with .rs extension!";
const TABLET_BROKEN_NAME_MSG: &str = "every tablet is expected to have a valid name!";

const REGISTRY_TEMPLATE: &str = "\
//! This is an internal `registry` of all available `notes`
//! 
//! `registry` is an entry point for all contained `notes` and it mods them all, so I can run all existing `doc tests`
//! also `registry` contains an `array` of all `notes` full paths, which is used in `Registry` API implementation inside `lib.rs`
//! 
//! The contents of this file are generated by the `build.rs` script. Do not edit manually

MODS

/// Special array containing all `note`s full paths
pub(crate) const TABLETS: [&str; SIZE] = [
PATHS];
";

const MOD_TEMPLATE: &str = "pub(crate) mod NAME;\n";
const PATH_TEMPLATE: &str = "\tconcat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/registry/NAME.rs\"),\n";

fn validate_path(path: &Path) {
    assert!(path.is_file(), "{SUBDIR_DETECTED_MSG}");
    assert_eq!(
        "rs",
        path.extension().expect(BAD_EXTENSION_MSG),
        "{BAD_EXTENSION_MSG}"
    )
}

fn catalog() -> Result<Vec<PathBuf>> {
    let mut catalog: Vec<PathBuf> = Vec::new();
    let registry_data = fs::read_dir(Path::new(REGISTRY_DIR))?;
    for entry in registry_data {
        let fpath = entry?.path();
        validate_path(&fpath);
        catalog.push(fpath);
    }
    Ok(catalog)
}

fn registry_code(catalog: Vec<PathBuf>) -> String {
    let mut mods = String::new();
    let mut paths = String::new();
    let size = format!("{}", catalog.len());
    for tablet in catalog.into_iter() {
        let name = tablet
            .file_stem()
            .expect(TABLET_BROKEN_NAME_MSG)
            .to_str()
            .expect(TABLET_BROKEN_NAME_MSG);
        mods.push_str(MOD_TEMPLATE.replace("NAME", name).as_str());
        paths.push_str(PATH_TEMPLATE.replace("NAME", name).as_str());
    }
    REGISTRY_TEMPLATE
        .replace("MODS", mods.as_str())
        .replace("PATHS", paths.as_str())
        .replace("SIZE", size.as_str())
}

fn main() -> Result<()> {
    let catalog = catalog()?;
    let registry_code = registry_code(catalog);
    fs::write(Path::new(REGISTRY_PATH), registry_code)?;
    Ok(())
}
